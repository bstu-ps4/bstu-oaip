<!--
# 2019-10-12_lecture.marktext
-->

## Базовые типы. Преобразование типов операндов арифметических операций

Типы операндов преобразуются в порядке увеличения их размера памяти. Можно говорить, что не явные преобразования всегда идут от меньших объектов к большим.

$short, char \rightarrow int \rightarrow unsigned \rightarrow long \rightarrow double$

$float \rightarrow double$

При выполнении операций могут встречаться операнды разных типов случае они приводятся к общему виду.

Значения типа char и short всегда преобразуется в int. Если один из операндов long, другой преобразуется в long. Если один из операндов double - в double.

``1/3`` будет ``0``, чтобы избежать этого нужно записать ``1./3``.

Типы char и int могут свободно смешиваться. Char преобразуется автоматически в int.

При присваивании значения правой части преобразуются к типу левой.

Тип левой путем является типом результата.

Тип double пробразуется во float округлением.

```c
float x, int i;
i = x // или x = i
```

float преобразуется в int отбрасыванием дробной части.

При передачи данных в функции тоже происходит преобразование типа.

## Операции приведения типа

Преобразование типов может осуществляться  явно. Для этого достаточно перед любым выражением поставить в скобках индификатор соответствующего типа. Результат этой операции приведет тип значение выражения. Эта операция вынуждает компилятор выполнить указанные преобразования, но ответ за последствие воздвигается на программу. Эту операцию рекомендуется использовать в исключительных случаях.

Вид записи операции:

```
(тип) выражение
```

Например:

```cpp
float x;
int n = 6, k = 4;
x = (n + k) / 3         // дробная часть будет отброшена
x = (float) (n + k) / 3 //использования операции типа здесь позволяет избежать округления результата деления целочисленных операндов
```

Если нужно преобразовать фактический параметр к типу соотвествующего формата параметра функции $\log{(double)x}$.

Функции в стандартных библиотеках заданы с типом double.

## Операции сравнения

|     |                        |
| --- | ---------------------- |
| ==  | равно или эквивалентно |
| !=  | не равно               |
| <   | меньше                 |
| <=  | меньше или равно       |
| >   | больше                 |
| >=  | больше или равно       |

Пары символов соответствующих операции разделять нельзя

Общий вид операции отношений:

```
<выражение1> <знак_операции> <выражение2>
```

Общие правила операции сравнения

1. Операндами могут быть любые базовые типы

2. Значения после вычисления перед сравнением преобразуются к одному типу

3. Результат операции отношения - целое значение 1, если отношение истино,
   
    в противном случае 0.
   
    Операция отношения может использоваться в любых арифметических выражениях.

## Логические операции

Перечень в порядке убывания приоритету

|      |                             |
| ---- | --------------------------- |
| !    | отрицание (логическое НЕТ)  |
| &&   | конъюнкция (логическое И)   |
| \|\| | дизъюнкция (логическое или) |

Пары чисел разделять нельзя

Общий вид операции отрицания:

```
!<выражение>
```

Общий вид операции конъюнкции и дизъюнкции:

```
<выражение1> <знак_операции> <выражение2>
```

Например:

|                  |                                             |
| ---------------- | ------------------------------------------- |
| y > 0 && x = 7   | истина, если 1-е и 2-е выражение истины     |
| e > 0 \|\| x = 7 | истина, если хотя бы одно выражение истинно |

Ненулевое значение операнда трактуется как “истина”, а нулевое - “ложь”

Например:

|     |     |
| --- | --- |
| !0  | 1   |
| !5  | 0   |

Особенность операции конъюнкции и дизъюнкции - экономное последовательное вычисление выражений-операндов:

```
<выражение1> <операция> <выражение2>
```

* если выражение1 операции конъюнкция ложно, то результат операции - ноль и выражение2 не вычисляется
* если выражение1 операции дизъюнкции истинно, то результат операции единица и выражение2 не вычисляется

Таким образом, появляется возможность записью логического выражения задать условную последовательность вычисления выражения в направлении слева направо

``scanf(“%d” &i) && test1(i) && test2(i)`` $\rightarrow$ ненулевой результат одной из функций приведет к игнорированию вызова остальных

``search1(x) || search2(x) || search3(x)`` $\rightarrow$ только ненулевой результат одной из функций приведет к игнорированию вызова остальных

Пример правильной записи двойного неравенства:
$0<x<100 \longleftrightarrow$ ``(0 < x) && (x < 100)``

## Побитовые логические операции. Операции над битами

В Си предусмотрен набор операция для работы с отдельными числами. Эти операции нельзя применять к перечным вещественого типа (float и double)

Перечень операций над битами и их обозначения:

|     |                                                                      |
| --- | -------------------------------------------------------------------- |
| ~   | дополнение (унарная операция), инвертирование (одноместная операция) |
| &   | побитовое И - конъюнкция                                             |
| \|  | побитовое включающие ИЛИ - дизъюнкция                                |
| ^   | побитовое исключающие ИЛИ - сложение по модулю 2                     |
| >>  | сдвиг вправо                                                         |
| <<  | сдвиг влево                                                          |

Пары символов (``>>``, ``<<``) разделять нельзя.

Общий вид операции инвертирования:

```~ <выражение>```

## Побитовые логические операции. Операции над битами

Остальные операции над битами имеют вид:

```<выражение1> <знак_операции> <выражение2>```

Операндами операции над битами могут быть только выражения, приводимые к целому типу. Операции (```~, &, |, ^```) выполняются поразрядно над всеми битами операндов (знаковый разряд особо не выделяется)

``~0xF0`` $\Longleftrightarrow$ ``x0F``

(~F0 = ~ 11110000 = 00001111 = 0F)

``0xFF & 0x0F`` $\Longleftrightarrow$ ``x0F``

(FF & 0F = 11111111 & 00001111 = 00001111)

``0xF0 | 0x11`` $\Longleftrightarrow$ ``xF1``

(F0 | 11 = 11110000 | 00010001 = 11110001)

``0xF4 ^ 0xF5`` $\Longleftrightarrow$ ``x01``

(F4 ^ F5 = 11110100 ^ 11110101 = 00000001 = 01)

Операции & часто используется для маскирования некоторого множества битов.

Например:

оператор ``w = n & 0177`` передает в ``w`` 7 младших битов ``n``, полагая остальные равные ``0``-лю.

(0177 = 0000 0001 0111 0111)

## Конъюнкция, дизъюнкция

Операция (``|``) используется для включения битов ``w = x | y``, устанавливает в единицу те биты в ``x``, которые ``= 1`` в ``y``.

Необходимо отличать побитовые операции ``&`` и ``|`` от логических операций ``&&`` и ``||``, которые подразумевают вычисление значение истинности слева направо. Если ``x = 1``, ``y = 2``, то ``x & y`` равно ``0``-лю, а ``x && y`` равно 1.

(1 & 2 = 0001 * 0010 = 0000 = 0)

(1 && 2 = [1≠0 и 2≠0] = [истина и истина] = 1)

## Операции сдвига

Операции сдвига выполняются для всех разрядов с потерей выходяще за границы битов.

Примеры:

0x81 << 1 $\Longleftrightarrow$ 0x02

(0x81 << 1 = 1000 0001 << 1 = 0000 0010 = 0x02)

0x81 >> 1 $\longleftrightarrow$ 0x40

(0x81 >> 1 = 1000 0001 >> 1 = 0100 0000 = 0x40)

$x << 1 \longleftrightarrow x * 2$

$x >> 1 \longleftrightarrow x / 2$

$x << 3 \longleftrightarrow x * 8$

Если выражение 1 имеет тип unsign, то при сдвиге вправо освобождающие разряды гарантированно заполняются 0.

Если тип sign могут, но не обязательно сдвигаться вправо с копированием знаковых разряда.

``>>>`` - не в Си

При сдвиге влево всегдазаполняется ``0``-ями.

Операции сдвига ``<<`` и ``>>`` осуществляют соответственно сдвиг вправо влево своего левого операнда, на число битовых позиций, задаваемых правым операндом. Таким образом, ``x << 2`` сдвигает ``x`` влево на ``2``-е позиции, заполняя освобождающиеся биты ``0``-ями, что эквивалентно умножению на ``4``.

Операции сдвига вправо на k разрядов весьма эффективны для деления в сдвиг  влево -  для умножения целых чисел на 2 в степени k:

## Дополнение

Унарная операция (``~``) дает дополнение к целому. Это означает, что каждый бит со значением ``1`` получает значение ``0`` и наоборот. Эта операция обычно оказывается полезной в выражениях типа:

``X & (~)077``,

где последние ``6`` битов ``X`` маскируются ``0``-ём.

## Сокращенная форма операции присваивания

Двуместные операции над битами (&, |, ^, <<, >>) могут использоваться в сокращенных формах записи операции присваивания:

```c
int i, j ,k;
```

|                                              |                                                        |
| -------------------------------------------- | ------------------------------------------------------ |
| i \= j $\longleftrightarrow$ i = i \| j      | включение в поле i единиц из поля j                    |
| i &= 0xFF $\longleftrightarrow$ i = j & 0xFF | выделение в поле i единиц по маске поля 0x00FF         |
| k ^= j                                       | выделение в поле k  отличающихся разрядов в поле k и j |
| i ^= i                                       | обнуление всех разрядов поля i                         |

---

## Операция , (запятая)

Используется при организации строго гарантированной последовательности в вычилении выражений.

``выражение1, ..., выражениеN``

``выражение1, ..., выражениеN`` вычисляется гарантированно последовательно и результатом операции становится значение выражения N.

Пример:

```c
m = (i = 1, j = i++, k = 6, n = i + j + k);
```

Получим последовательность вычислений ``i = 1``, ``j = i = 1``, ``i = 2``, ``k = 6``, ``n = 2 + 1 + 6`` и в результате ``m = n = 9``.

Данный пример ничем не отличается от такого участка кода: 

```c
i = 1;
j = i;
i++;
k = 6;
n = i + j + k;
m = n;
```
