\subsection{Объединения}

\underline{Объединения} - объект позволяющий нескольким переменным различных типов занимать 1-ин участок памяти.

Пример:

\begin{verbatim}
union unit {
    int i;
    char ch;
}
\end{verbatim}

Объявление объединения похожа на объявления структуры.

Как и для структур можно и объвлять переменну. поместив её имя в конец определения или используя отдельный операто объявления:

\begin{verbatim}
union un_t me_rerem;
\end{verbatim}

Теперь в \texttt{my\_rerem} целое число \texttt{i} и символ \texttt{ch} занимает 1-ин участок памяти.

...картинка...

В этом случае можно обратится к данным как к целому числу или символу.

Компилятор автоматически создаёт переменную достаточного размера для хранения наибольшего переменной, которая присутствует в объединении.

Для доступа к полям объединения используется оператор "точка", "стрелка".

Пример:

\begin{verbatim}
me_perem.i = 10;
\end{verbatim}

Если используется объединения код становится машино не зависим - можно переносить на другой компьютер

Определим переменную или объединещ типа с помощью анонимного шаблона:

\begin{verbatim}
union {
    long L;
    unsigned i1;
    int i2;
    char c[4];
} UNI;
\end{verbatim}

Из схемы разммещения памяти они размещаются с одного адреса

Вывод адреса переменных он будет один и тот же:

\begin{verbatim}
cout << &UNI.L; //все переменные имеют один и тот же адрес
cout << &UNI.i1;
cout << &UNI.i2;
cout << &UNI.c;
\end{verbatim}

Тип поля может быть любым в том числе и структуры, т. е. структуры могут полями объединения и объдинения могут быть полем структуры.

Также разрешается и создания массива объединений.

Доступ к полям объединения:

\begin{verbatim}
имя_объединения.имя_поля
(*указатель_объединения).имя_поля_указателя_объединение->имя_поля
ссылка_на_объединение.имя_поля
\end{verbatim}

Если объединение анонимно, а имена у него уникально, то можно его поля использовать как переменные.

Член - данные анонимного объединения можно использовать как переменные (если их имена уникальны в контексте объявления).

Например:

\begin{verbatim}
enum week {sum, mon, tues, wed, thurs, fri, sat};
union { //анонимное объединение
    int i;
};
week w;
i = 6;
if ( (w == sun) || (w == sat) )
    cout << "Это выходные дни";
\end{verbatim}

Заносить значения в участок памяти, выделенный для объединения, можно с помощью любого из элементов:

\begin{verbatim}
union {
    int ival;
    float fval;
    char cval[4];
} nval;
\end{verbatim}

Переменной \texttt{uval} можно присваивать любой из 3-ех типов, какой тип в данный момент находится в переменной должен помнить программист. Но инициализировать объединения может только 1-ым описаным...

\underline{Инициализатор объединения} - заключение для его 1-го поля, заключенное в фигурных скобки.

Например:

\begin{verbatim}
union int_flt {
    int i;
    float x;
} n = {0}; //поле i инициализируется нулём
n.i = 7; //в объединении записано целое значение
cout << n.i << endl; //объединение инициализируется как имеющее целый тип
n.x = 7.0; //в объединении записано вещественное значение
cout << n.x << endl; //объединение интерпретируется как имеющее вещественный тип.
\end{verbatim}

Можно присвоить объединение вещественного значение:

\begin{verbatim}
fk.f = -256.5;
\end{verbatim}

А рассматривать его как безнаковое целое:

\begin{verbatim}
cout << hex << fk.k; //получим с3804000 16$.
\end{verbatim}