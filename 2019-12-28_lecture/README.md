<!--
# 2019-12-28_lecture.marktext
-->

## Передача многомерных массивов

```c
int sum(int **a, const int nstr, const int nstb) {
    int i, j, s = 0;
    for (i = 0; i < nstr; i++)
        for (j = 0; j < nstr; j++)
            s += a[i][j];
    return s;
}

int main() {
    ...
    int nstr, nstb;
    cin >> nstr >> nstb;
    int i, j;
    //Формирование матрицы
    int **a = new int *[nstr];
    for (i = 0; i < nstr; i++)
        a[i] = new int [nstb];
    for (i = 0; i < nstr; i++)
        for (j = 0; j < nstb; j++)
            cin >> a[i][j];
    cout << sum(a, nstr, nstb);    
    ...
}
```

## Операция typedef

Любому типу данных, как стандартному, так и определённому пользователем, можно задать новое имя с помощью операции typeof:

```c
typedef unsigned int UINT;
```

```c
typedef char M_s[100];
```

декларация идентификаторов введённых типов имеют вид:

`UNIT i, j;` -> две переменные типа unsigned int

`M_s str[10]` -> массив из 10 строк по 100 символов

## Указатели на функции

В языке Си индефикатор функции является константным указателем на начала функции в оперативной памяти, и не может быть значением переменной, но имеется вохможность декларировать указатели на функции, с которыми можно обращаться как с переменными. Например, можно создать массив, элементами которого будут указатели функции.

Как и любой объект языка Си нужно декларировать.

Формат объявления указателя на функции слудующий:

```
тип (*переменная-указатель) (список параметров);
```

ЗДесь декларируется указатель устанавливающий на функции возвращающий результат данного типа.

Наличие первых круглых скобок обязательна, без них получилась бы функция возвращающая указатель.

Например:

```c
float (*p_f) (char, float);
```

это объявление говорит, что декларируется указатель p_f, который устанавливается на функции и имеет результат символьного и вещественого типа.

2 шаг) Чтобы установить переменную указатель на конкретную функцию достаточно ей присвоить её индентификатор.

```
переменная-указатель = ID_функции;
```

Например, имеется функция с прототипом `float s1(char, float);`, тогда операция `p_f = f1;` установит `p_f` на данную функцию.

3 шаг) Вызов функции после установки на неё указателя выглядит так:

```
(*переменныя-указатель) (список аргументов)
```

или

```
переменная-указатель (список аргументов);
```

`p_f` является началом функции в оперативной памяти, поэтому последняя строка справедлива. После таких действий, кроме стандартного обращения к функции.

```
ID_функции (список аргументов);
```

появляется ещё два способа вызвать функции:

```
(*переменная-указатель) (список аргументов);
```

или

```
переиенная-указатель (список аргументов);
```

```c
f1('z', 1.5);     //обращение к функции по ID
(*p_f)('z', 1.5); //обращение к функции по указателю
p_f('z', 1.5);    //обращение к функции по ID указателя
```

Пусть имеется 2-ая функция с прототипом:

```c
float f2(char, float);
```

тогда передставив указатель `p_f` на эту функцию `p_f = f2;` имеет опять 3-и способа её вызова:

```c
f2("z", 1.5);     //по ID функции
(*p_f)("z", 1.5); //по указателю на функции
p_f("z", 1.5);    //по ID указателя на функции
```

Основное назначение указателя на функции - обеспечение возможности передачи индентификаторов функции в качестве параметров на функцию, которая реализует некоторый вычислительный процесс используя формальное имя вызываемой функции.

Пример:

Написать функцию вычисления суммы sum обозначив слагаемое формальной функции fun(x), а при вызове функции суммирования передавать через через параметр реальное имя функции, в которой запрограммирован явный вид этого слагаемого.

Пусть надо вычислить две суммы s1 и s2.

$$
s1 = \sum^{2n}_{i=1}{x\over5}
$$

и

$$
s2 = \sum^n_{i=1}{x\over2}
$$

Поместив слагаемые этих сумм в пользовательские функции f1 и f2.

При этом для более удобной работы воспользуемся операцией `typedef`, c помощью которой, введём пользовательский тип данных: указатель на функции, который можно устанавливать на функции возвращающий результат указаного типа и имеющие указанный список параметров.

Тогда в списке параметров функции суммирования достаточно указывать фактический ID функции данного типа.

Пример:

```c
//Декларация пользовательского типа: указатель на функции
//возвращающие float результат и имеющие один float параметр
typedef float (*p_f) (float);

float sum(p_f fun, int, float); //декларация прототипов функции
float f1(float);
float f2(float);

void main(void) {
    float x, s1, s2;
    int n;
    puts("Введите количетсво слагаемых n и значения x:");
    scanf("%d%f", &n, %x);
    s1 = sum(f1, 2 * n, x);
    s2 = sum(f2, n, x);
    printf("\n\tN = %d, x = %f", n, x);
    printf("\n\tСумма 1 = %f\n\tСумма 2 = %f", s1, s2);
}

//Функция вычисления суммы, первый параметр - формальное имя
//функции, введенного с помощью typeof типа
float sum(p_f fun, int n, float x) {
    float s = 0;
    for (int i = 1; i <= n; i++)
        s += fun(x);
       return s;
}

//Первое слагаемое
float f1(float r)
    return r / 5;

//Второе слагаемое
float f2(float r)
    return r / 2;
```

## Параметры командной строки финкции `main()`

Функция `main()` может быть определена с параметром, которые передаются из внешнего окружения, например, из командной строки.

Во внешнем окружении все данные представляются в виде строк символов.

Для передачи этих строк в main используется 2-ва параметра:

- для передачи числа передаваемых строк

- для передачи самих строк

Общепринятые параметры `argc`, `argv`.

Параметр `arcc` имеет тип int, его значение равно количеству слов в командной строке.

Параметр `argv` - массив указателей на строки, каждая из которой содержит одно слово из командной строки.

Если слово должно содержать пробел, то при ... в строку должно заключено в кавычки.

Параметр `argp`, который служит для передачи в main параметра операционной системы, которой выполняется программа.

```c
int main(int argc, char *argv[], char *argp[])
```

Если командная трока имеет вид:

```powershell
a:\> cprog working 'C program' 1
```

Пример:

argc[4]

argv[] -> [] -> [a:\cprog.exe\0]

[] -> [working\0]

[] -> [C program\0]

[] -> [1\0]

[NULL]

argp[] -> [] -> [path = a:\; c:\\\0]

[] -> [lib = d:\lib\0]

[] -> [include = d:\include]

[] - >

Параметры со значением по умолчанию, чтобы упростить вызов функции в её заголовке можно указать значения по умолчанию, важно, чтобы эти параметры были последним в списке и они могут опускаться при вызове функции.

В качестве значений параметров по умолчанию могут записываться константы глобальные переменные, выражения.

```c
int f(int a, int b = 0);
void f1(int, int = 100; char* = 0);
/*обратите внимание на пробел мужду * и = (без него получилась бы операция сложного присваивания *=)*/
void err(int err value = errno);
//errno - глобальная переменная
```

Варианты вызова функции

```c
f(100);  //по умолчанию b = 0
f(a, 1); //b явно присвоено значение 1
f1(a);   //первому формальному параметру присвоено значение переменной
```
