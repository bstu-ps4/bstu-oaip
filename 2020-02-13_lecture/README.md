<!--
# 2020-02-13_lecture.marktext
-->

# Структуры. Объединения. Определяемые пользователем типы

> Язык Си предоставляет 5 способов создания своих типов данных: 

1. Структура – совокупность переменных, объединенных одним именем. 
2. Битовое поле – разновидность структуры, предоставляющая легкий доступ к 
   отдельным битам. 
3. Объединение – позволяет одному участку памяти содержать два или более 
   различных типов данных. 
4. Перечисление – список символов. 
5. Typedef – ключевое слово, которое создает новое имя существующему типу. 

Структура – совокупность переменных, объединенных одним именем, представляющая общепринятый способ совместного хранения информации. 

> Объявление структуры приводит к образованию шаблона, который дальше используется для создания объектов структуры. 

> <u>Переменные, образующие структуры</u>, называются <u>полями или элементами структуры</u>. 

> Обычно все поля структуры связаны друг с другом (по смыслу). 

Объявление шаблона, определяющего имя, адрес: 

> Ключевое слово struct объявляет компилятору об объявлении структуры. 

```c
struct addr { 
    char name [30];
    char street [40];
    char city [20];
    char state [3];
    unsigned long int zip;
};
```

Объявление переменной:

```c
struct addr addr_info;
```

> Объявление структуры заканчивается точкой с запятой (`;`), потому что это оператор. Имя структуры (в нашем случае `addr`) идентифицирует структуру и объявляется спецификатором типа.

> На данный момент ещё не создана переменная, создан только тип и определена форма данных. Для определения переменной созданной структуры нужно написать: 

```c
struct addr addr_info; 
```

> В этой строке происходит объявление `addr_info` типа `addr`.

> Когда объявлена структурная переменная, компилятор автоматически выделяет необходимый участок памяти для размещения всех полей.

Размещение структуры addr_info в памяти:

<table>
    <tr>
        <td>name</td>
        <td>30 bytes</td>
        <td rowspan="5">addr_info</td>
    </tr>
    <tr>
        <td>street</td>
        <td>40 bytes</td>
    </tr>
    <tr>
        <td>city</td>
        <td>20 bytes</td>
    </tr>
    <tr>
        <td>state</td>
        <td>3 bytes</td>
    </tr>
    <tr>
        <td>zip</td>
        <td>4 bytes</td>
    </tr>
</table>

Стандартный вид объявления структуры: 

```c
struct ярлык {
    тип имя переменной;
    тип имя переменной;
    тип имя переменной;
} структурые переменные;
```

<u>Ярлык</u> – имя типа структуры, а не имя переменной.

<u>Структурные переменные</u> – разделенный запятыми список имён переменных.

Следует помнить, что или ярлык или структурные переменные могут отсутствовать, но не оба.

> Можно объявлять более естественную структуру переменных: 

Объявление 1-ой переменной: 

```c
struct { 
    char name [30];
    сhar street [40];
    char city [20];
    char state [3];
    unsigned long int zip;
} addr_ info;
```

Объявление нескольких переменных:

```c
struct addr { 
    char name [30];
    сhar street [40];
    char city [20];
    char state [3];
    unsigned long int zip;
} addr_info, binfo, cinfo;
```

> Каждая новая структурная переменная содержит свою собственую копии... Между ними нет связи, они просто являются экземплярами одного типа структуры. 

<div style="page-break-after: always"></div>

# Доступ к полям структуры

> Доступ к отдельным полям структуры осущeствляется с помощью оператора точка (`.`).

Стандартный вид доступа:

```
имя_структуры.имя_поля
```

Примеры: 

- присваиваем полю `zip` структурной переменной `addr_info` значение `12345`: 
  
  ```c
    addr_info.zip = 12345;
  ```

- выводим поле `zip` на экран: 
  
  ```c
    printf ("%ld", addr_info.zip);
  ```
  
  > Эта строка выводит на экран структурное поле `zip`.

- передаем указатель на символ, указывающий на начало name: 
  
  ```c
    gets (addr_info.name);
  ```
  
  > Использует массив символом `addr.name`.
  
  > Эта команда передаёт символ указывающий на начало `name`.

<div style="page-break-after: always"></div>

# Присваивание структур

> Информация, содержащаяся в одной структуре может быть присвоена другой структуре того же типа с помощью одиночного оператора присваивания. То есть не нужно присваивать значение каждого поля по отдельности.

Программа демонстрирует присваивание структур:

```c
#include <stdio.h> 

int main (void) { 
    struct { 
        int a;
        int b;
    } x, y;

    x.a = 10;
    x.b = 20;
    y = x; /* присвоение одной структуры другой */
    printf("Contents of y: %d %d.", y.a, y.b);

    return 0;
}
```

После присваивания переменные `y.a` и `y.b` будут содержать значения `10` и `20` соответственно.

<div style="page-break-after: always"></div>

# Массивы структур

> Наиболее часто массивы используются в виде массивов структур. 

> Для объявления массива структур следует сначала определить структуру, а затем объявить массив переменных данного типа. 

В примере объявляется 100-элементный массив структур типа `addr`:

```c
struct addr addr_info[100]; 
```

> В результе мы получим набор из 100 переменных, устроенных как объявлено в типе структуры `addr`.

> Для доступа к отдельным структурам массива `addr_info` стоит проиндексировать имя массива.

Пример вывода содержимого поля zip третьей структуры:

```c
print("%ld",addr_info[2].zip);
```

<div style="page-break-after: always"></div>

# Передача структур в функции

> Рассмотрим передачу полей и структур в функции. 

> В этом случае фактически передается значение поля, то есть обычная переменная.

> В примере объявляем структуру и затем передаем каждое поле этой структуры в функцию:

```c
struct frend { 
    char x;
    int y;
    float z;
    char s[10];
} mike;
```

Примеры передачи каждого поля в функцию:

```c
func(mike.x); /* передача символьного значения x */
func2(mike.y); /* передача целочисленного значения y */
func3(mike.z); /* передача вещественного значения z */
func4(mike.s); /* передача адреса строки s */
func(mike.s[2]); /* передача символьного значения s[2] */ 
```

Если необходимо передать адрес отдельного поля структуры, следует поместить `&` перед именем структуры: 

```c
func(&mike.x); /* передача адреса символа x */
func2(&mike.y); /* передача адреса целого y */
func3(&mike.z); /* передача адреса вещественного z */
func4(mike.s); /* передача адреса строки s */
func(&mike.s[2]); /* передача адреса символа s[2] */
```

> Нужно обратить внимание, что & cтоит перед именем структуры, а не перед именем поля. Массив s сам по себе является адресом, поэтому не надо адреса, но когда осуществляется доступ к символу строки s (5 строка), то `&` необходим.

Передача всей структуры в функцию.

> Когда структуры используются как аргумент функции, передается вся структура с помощью стандартной передачи по значению. (копия значения, то есть изменения не влияют на структуру, используемую в качестве аргумента).

> Так же важно помнить, что тип аргумента должен соответствовать типу параметра. Для этого лучше всего определить структуру глобально и затем использовать её ярлык для объявления неоходимых структурных переменных и параметров. 

```c
#include <stdio.h>

/*объявление типа структуры*/
struct struct_type { 
    int a, b;
    char ch;
};

void f1 (struct_type parm);

int main (void) { 
    struct struct_type.arg; /* объявление arg */
    arg.a = 1000;
    f1(arg);

    return 0;
}

void f1(struct struct_type parm) { 
    printf ("%d", parm.a);
}
```

> Данная программа выводит число `1000` на экран.

> Можно видеть `arg` и `param` объявлены типа `struct_type`.

<div style="page-break-after: always"></div>

# Указатели на структуры

> Язык Си позволяет создавать указатели на структуры так же, как и на другие типы переменных. 

> Указатель на структуры объявляется путем помещения звездочки (`*`) перед именем структурной переменной.

Следующая строка объявляет `addr_pointer` как указатель на данные этого типа:

```c
struct addr *addr_pointer; 
```

Для получения адреса структурной переменной следует поместить оператор & перед именем структуры. Пусть имеется следующий фрагмент:

```c
struct bal { 
    float balance;
    char name[80];
} person; 

struct bal *p; /* объявление указателя на структуру */ 
```

тогда

```c
p = &person;
```

помещает адрес структуры `person` на указатель `p`.

Для доступа к членам структуры с помощью указателя на структуру следует использовать оператор "стрелка". 

Например:

```c
p -> balance //не через точку
```

<div style="page-break-after: always"></div>

# Массивы и структуры в структурах

> <u>Поле структуры</u> может быть как <u>простым</u>, так и <u>составным</u>.

> <u>Простое поле</u> – обычный базовый тип данных.

> <u>Составные типы</u> являются <u>одномерными или многомерными массивами</u> различных типов данных и структур.

```c
struct x { 
    int a[10][10];
    float b;
} y;

y.a[3][7]
```

> Структура `addr` вложена в структуру `emp`:

```c
struct emp { 
    sruct addr address;
    float wage;
} worker;

worker.wage = 35000.00;
worker.address.zip = 98765;
```
