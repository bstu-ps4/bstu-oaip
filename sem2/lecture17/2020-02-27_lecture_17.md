<!--
# 2020-02-27_lecture_17
-->

# Битовые поля, объединения, перечисления

В Си есть возможность, которая называется битовыми полями, что позволяет работать с отдельными видами.

Причины по которым полезны битовые поля:

1) Можно сохранить несколько переменных в 1-ом байте
2) некоторые интэрфэйсы устройств передают информацию закодировав бит в 1-ин байт
3) существует процедуры кодировани, которые осуществляют доступ к отдельному биту

Метод использования битовых полей основан на структурах

Битовое поле - особый вид структуры определяющий какую длину имеет кодовое поле.

Стандартный вид оъявления битовых полей:

```c
struct имя_структуры {
    тип имя1: длина;
    тип имя2: длина;
    ...
    тип имяN: длина;

}
```

тип - int, unsigned, signed.

Битовые поля должны объявляться и иметь длину 1-16 бит (в 16 битных средах)

Пример:

```c
struct device {
    unsigned active: 1;
    unsigned ready: 1;
    unsigned error: 1;
} dev_code;
```

Данная структура определяет тип переменной по 1-ому биту каждому.

Структурная переменная dev_code может использована для декодирования информации порта ленточного накопителя.

Для такого гипотетического ленточного накопителя следующий фрагмент кода записывает байт информации на ленту и проверяет на ошибки, используя dev_code:

```c
void wr_tape(char c) {
    while(!dev_code.ready)
        rd(&dev_code); //ждать
    wr_to_tape(c); //запись байта
    while(dev_code.active)
        rd(&dev_code); //ожидание кончания записи информации
    if(dev_code.error)
        printf("Write Error");
}
```

Здесь rd() возвращает статус ленточного носителя, wr_to_tape() записывает данные.

Рисунок показывает как выглядит переменная dev_code в памяти:

...картинка...

К полю происходит обращение с помощью оператора "точка". Если обращение к структуре происходит с помощью указателя, то вместо "точки", используется оператор "стрелка".

Нет необходимости обзывать каждое битовое поле.

Если ленточный накопитель возвращает информацию, о наступлении конца ленты в 5-ом байте, следует применить структуру device следующим образом:

```c
struct device {
    unsigned active: 1;
    unsigned ready: 1;
    unsigned error: 1;
    unsigned : 2;
    unsigned EOT: 1;
} dev_code;
```

Ограничение битовых полей:

- нельзя получить адрес переменной битового поля
- переменные битового поля не могут помещаться в массив
- переходя с компьютера на компьютер нельзя быть уверены... зависит от компьютера

Можно смещивать различные структурные переменные в битовых полях:

```c
struct emp {
    struct addr address;
    float pay;
    unsigned lay_off: 1;
    unsigned hourly: 1;
    unsigned deductions: 3;
};
```

определяет запись служащего, использующую только 1-ин байт для хранения 3-ех частей информации статуса служащего...

## Объединения

**Объединения** - объект позволяющий нескольким переменным различных типов занимать 1-ин участок памяти.

Пример:

```c
union unit {
    int i;
    char ch;
}
```

Объявление объединения похожа на объявления структуры.

Как и для структур можно и объвлять переменну. поместив её имя в конец определения или используя отдельный операто объявления:

```c
union un_t me_rerem;
```

Теперь в my_rerem целое число i и символ ch занимает 1-ин участок памяти.

...картинка...

В этом случае можно обратится к данным как к целому числу или символу.

Компилятор автоматически создаёт переменную достаточного размера для хранения наибольшего переменной, которая присутствует в объединении.

Для доступа к полям объединения используется операто "точка", "стрелка".

Пример:

```c
me_perem.i = 10;
```

Если используется объединения код становится машино не зависим - можно переносить на другой компьютер

Определим переменную или объединещ типа с помощью анонимного шаблона:

```c
union {
    long L;
    unsigned i1;
    int i2;
    char c[4];
} UNI;
```

Из схемы разммещения памяти они размещаются с одного адреса

Вывод адреса переменных он будет один и тот же:

```cpp
cout << &UNI.L; //все переменные имеют один и тот же адрес
cout << &UNI.i1;
cout << &UNI.i2;
cout << &UNI.c;
```

Тип поля может быть любым в том числе и структуры, т. е. структуры могут полями объединения и объдинения могут быть полем структуры.

Также разрешается и создания массива объединений.

Доступ к полям объединения:

```c
имя_объединения.имя_поля
(*указатель_объединения).имя_поля_указателя_объединение->имя_поля
ссылка_на_объединение.имя_поля
```

Если объединение анонимно, а имена у него уникально, то можно его поля использовать как переменные.

Член - данные анонимного объединения можно использовать как переменные (если их имена уникальны в контексте объявления).

Например:

```cpp
enum week {sum, mon, tues, wed, thurs, fri, sat};
union { //анонимное объединение
    int i;
};
week w;
i = 6;
if ( (w == sun) || (w == sat) )
    cout << "Это выходные дни";
```

Заносить значения в участок памяти, выделенный для объединения, можно с помощью любого из элементов:

```c
union {
    int ival;
    float fval;
    char cval[4];
} nval;
```

Переменной uval можно присваивать любой из 3-ех типов, какой тип в данный момент находится в переменной должен помнить программист. Но: инициализировать объединения может только 1-ым описаным...

**Инициализатор объединения** - заключение для его 1-го поля, заключенное в фигурных скобки.

Например:

```c
union int_flt {
    int i;
    float x;
} n = {0}; //поле i инициализируется нулём
n.i = 7; //в объединении записано целое значение
cout << n.i << endl; //объединение инициализируется как имеющее целый тип
n.x = 7.0; //в объединении записано вещественное значение
cout << n.x << endl; //объединение интерпретируется как имеющее вещественный тип.
```

Можно присвоить объединение вещественного значение:

```c
fk.f = -256.5;
```

А рассматривать его как безнаковое целое:

```c
cout << hex << fk.k; //получим с3804000 16$.
```
