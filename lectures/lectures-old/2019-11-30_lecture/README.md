<!--
# 2019-11-30_lecture.marktext
-->

**Сортировка выбора** - это алгоритм последовательного обмена минимального и первого элементов неотсортированной части массива.

Массив также делится на 2-е части:

- отсортированную, или "готовую" последовательность $a_1,...,a_{i-1}$
- не отсортированную, или "исходную" $a_i,...,a_n$

На момент начала сортировки методом простого выбора готовая последовательность считается пустой, соотвественно, исходная последовательность включает в себя все элементы массива.

Алгоритм сортировки с помощью прямого выбора можно описать следующим образом:

- из всего массива выбирается элемент с наименьшим значением
- он меняется местами с первым элементом $a_1$.
- затем этот процесс повторяется с оставшими $n-1$ элементами, $n-2$ элементами и т. д. до тех пор, пока не останется один элемент с наибольшим значением.

Пример сортировки простого выбора:

|       |           |           |           |           |           |     |
| ----- | --------- | --------- | --------- | --------- | --------- | --- |
|       | 35        | 12        | 28        | 47        | 20        | 31  |
| i = 2 | <u>12</u> | 35        | 28        | 47        | 20        | 31  |
| i = 3 | <u>12</u> | <u>20</u> | 28        | 47        | 35        | 31  |
| i = 4 | <u>12</u> | <u>20</u> | <u>28</u> | 47        | 35        | 31  |
| i = 5 | <u>12</u> | <u>20</u> | <u>28</u> | <u>31</u> | 35        | 47  |
| i = 6 | <u>12</u> | <u>20</u> | <u>28</u> | <u>31</u> | <u>35</u> | 47  |

Описание функции сортировки методом простого выбора:

```c
void SelectionSort(int k, int x[max]) {
    int i, j, min, temp;
    for (i = 0; i < k - 1; i++) {
        // установление начального значения минимального индекса
        min = i;
        // находим индекс минимального элемента
        for (j = i + 1; j < k; j++)
            if(x[j] < x[min])
                min = j; //меняем значение местами
        temp = x[i];
        x[i] = x[min];
        x[min] = temp;
    }    
}
```

## Быстрая сортировка Хоара (сортировка разделения)

- сортировка разделением (Quick sort)

- алгоритм разработанный английским информатиком Чарльзом Хоаром

- используется в стандартных утилитах сортировки

- основан на использовании обменого метода сортировки "разделяй и властвуй"
1. Из массива выбирается элемент, называемым опорным ``a[i]``.

2. Сравнение все остальные элементы с опорным, на основании сравнения разбить множество на 3-и:
   
   - "меньше опорного",
   
   - "равные",
   
   - "большие".
     
     Разложить их в порядке меньшие - равные - большие.
     
     |            |        |            |
     | ---------- | ------ | ---------- |
     | $\le a[i]$ | $a[i]$ | $\ge a[i]$ |

3. Для обоих подмассивов, если в подмассиве более двух элементов, рекурсивно запускает для него ту же процедуру.

На входе массив ``a[0]..a[N]`` и опорный элемент p, по которому будет производится разделение.

1. Введём два указателя i и j. В начале алгоритма они указывают соотвественно, на левый и правый конец последовательности.
2. Будем двигать указатель ``i`` с шагом в 1-ин элемент по направлению к концу массива, пока не будет найден элемент ``a[i] >= p``. Затем аналогичным образом начнём двигать указатель j от конца массива к началу, пока не будет найден ``a[j] <= p``.
3. Далее, если ``i <= j``, меняем ``a[i]`` и ``a[j]`` местами и продолжаем двигать i, j по тем же правилам. Повторяем шаг 2-3, пока ``i <= j``.

Рассмотрим работу процедуры для массива ``a[0]..a[6]`` и опорного элемента ``p = a[3]``.

|                               |     |     |     |          |     |     |     |
| ----------------------------- | --- | --- | --- | -------- | --- | --- | --- |
| Исходное положение указателей | 4   | 9   | 7   | <u>6</u> | 2   | 3   | 8   |
|                               | i   |     |     |          |     |     | j   |
| Положение 1-ого обмена        | 4   | 9   | 7   | <u>6</u> | 2   | 3   | 8   |
|                               |     | i   |     |          |     | j   |     |
| Положение 2-ого обмена        | 4   | 3   | 7   | <u>6</u> | 2   | 9   | 8   |
|                               |     |     | i   |          | j   |     |     |
| Конец процедуры               | 4   | 3   | 2   | <u>6</u> | 7   | 9   | 8   |
|                               |     |     | j   |          | i   |     |     |

Псевдокод

```
quickSort(массив a, верхняя граница N) {
    Выбрать опорный элемент p - середину массива.
    Разделить массив по этому элементу.
    Если подмассив слева от p содержит более одного элемента, вызвать quickSort для него.
    Если подмассив справа от p содержит более одного элемента, вызвать quickSort для него.
}
```

``template <class T>`` - шаблон для того чтобы копировать обобщенных алгоритмов без превязки длина данных.

```c
void quickSort(T*a, long N) {
    //на входе массив a[], a[N] - его последний элемент
    long i = 0; j = N - 1; // подставить указатели на исходные местами
    T temp p;
    p = a[N >> 1]; //центральный элемент
    //процедура разделения
    do {
        while (a[i] < p)
            i++;
        while (a[j] > p)
            j--;
        if (i <= j) {
            temp = a[i];
            a[i] = a[j];
            a[j] = temp;
            i++;
            j--;
        }
    } while (i <= j);
    // рекурсивный вызов, если есть что сортировать
    if (j > 0)
        quickSortR(a, i);
    if (N > i)
        quickSortR(a + i, N - i);
}
```

Краткие итоги

- задачи сортировок массива имеют широкие прикладные значения
- существуют большие количества алгоритмов сортировок массивов различающихся трудоемкостью.
- при оценке трудоемкостиалгоритмов учитываются критерии:
  - количество сравнений и перестановок
  - время в лудшем и худшем случаях
  - естественность поведения

К алгоритмам простых сортировок относятся:

- пузырьковая сортировка
- сортировка методом простого выбора
- сортировка методом простого включения

Простые сортировки эффективны для небольшимз объемов данных.

## Оценка алгоритмов сортировки

- ``n`` - число сортируемых элементов массива.
- внешний цикл выполняется $(n-1)$ раз
- внутрений цикл выполняется $n \over 2$ раз
- число операций сравнения $(n^2-n) \over 2$ - всегда
- **пузырьковая**:
- число операций обмена:
- наилутший случай - 0
- средний случай - $3/4 (n^2-n)$
- наихудший случай - $3/2 (n^2-n)$
- сложность: $O(n^2)$
- число сравнений не изменяется $(n^2 - n) / 2$
- число сравнений уменьшается лишь на незначительную величину
- **шейкерная**:
- сложность: $O(n^2)$
- алгоритм делает $n-1$ итераций, на каждой из которых осуществляется ещё $n-i$ проходов (сравнений) и одна перестановка.
- внешний цикл выполняется $(n-1)$ раз
- внутрений цикл выполняется $n \over 2$ раз
- **прямой выбор**:
- число сравнений: $1/2 (n^2-n)$
- число операций обмена
  - лутший случай - $3(n-1)$
  - худший случай - $n^2/4+3(n-1)$
  - средний случай - $n( \ln{n}+y), y ~ 0,577216$
- общее количество операций: $n+(n-1+1)+(n-2+1)+...+2=1/2(n^2+2n)!$
- сложность $~O(n^2)$.
- число операций сравнения зависит от исходной упорядочености массива элементов
- упорядоченный массив $=(n-1)$
- упорядоченный в обратном порядке $1/2(n^2+n-1)$
- среднее значение $1/4(n^2+n-2)$
- **прямое включение**:
- число операций обмена:
  - лутший случай $=2(n-1)$
  - средний случай $=1/n(n^2+9n-10)$
  - худший случай $1/2(n^2+3n-4)$
- среднее, а также худшее число сравнений и перестановок оцениваются как $O(n^2)$
- **Быстрая**:
- сложность: $O(n \log{n})$

Метод неустойчивости, т. е. число сравнений варьируется $O(n^2)$ операций, если каждый раз в качестве центрального элемента выбирается максимум или минимум входной последовательности.

Сортировка используется дополнительную память, так как приблизительная глубина рекурсивна рекурсии составляет $O( \log{n})$, а данные о рекурссивных поддывах кадый раз добавляются в стек.

## Модульное программирование

С увеличением объема программы становится не возможно удерживать в памяти все детали. Естественым способом борьба со сложностьлюбой задач является её разбивание на части.

В языках Си и С++ задача на может быть разбита на простые функции. После чего программу можно рассматривать в более укрупленном виде, а именно на уровне взаимодействия функций, т. е. использование функции ведёт к повышении степени абстракции программы и упрощения её структуры.

Разбиение программы на функции также позволяет избежать избыточности, кода, поэтому, что функции записывают 1-ин раз, а вызвать её на выполнении можно многократно из разных точек программы.

Процесс откладки программы содержащий функции можно лутче структурировать.

Часто используемые функции можно помещать в библиотеки. Такие образом создаются более простые в откладке программы.
