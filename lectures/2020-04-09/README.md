Файлы в языке С
===============

Файл – это набор данных, размещенный на внешнем носителе и рассматриваемый в процессе обработки и пересылке как единое целое. В файлах размещаются данные, предназначенные для длительного хранения.

Различают два вида файлов: текстовые и бинарные. Текстовые файлы представляют собой последовательность ASCII символов и могут быть просмотрены и отредактированы с помощью любого текстового редактора.

Бинарные (двоичные) файлы представляют собой последовательность данных, структура которых определяется программно.

В языке Си имеется большой набор функций для работы с файлами, большинство которых находятся в библиотеках **stdio.h** и **io.h**.

Открытие файла
--------------

Каждому файлу присваивается внутреннее логическое имя, используемое в дальнейшем при обращении к нему. Логическое имя (идентификатор файла) - это указатель на файл, т.е. на область памяти, где содержится вся необходимая информация о файле. Формат объявления указателя на файл следующий:

```c
FILE* указатель на файл;
```

FILE - идентификатор структурного типа, описанный в стандартной
библиотеке

stdio.h и содержащий следующую информацию:

```c
type struct {
    short level; //число оставшихся в буфере непрочитанных байт; обычный размер буфера - 512 байт; как только level=0, в буфер из файла читается следующий блок данных;
    unsigned flags; // - флаг статуса файла - чтение, запись, дополнение;
    char fd; // - дескриптор файла, т.е. число, определяющее его номер;
    unsigned char hold; // - непереданный символ, т.е. ungetc-символ;
    short bsize; // - размер внутреннего промежуточного буфера;
    unsigned char buffer; // - значение указателя для доступа внутри буфера, т. е. задает начало буфера, начало строки или текущее значение указателя внутри буфера в зависимости от режима буферизации;
    unsigned char *curp; // - текущее значение указателя для доступа внутри буфера, т.е. задает текущую позицию в буфере для обмена с программой;
    unsigned istemp; // - флаг временного файла;
    short token; // - флаг при работе с файлом;
} FILE;
```

Прежде, чем начать работать с файлом, т.е. получить возможность чтения или записи информации в файл, его нужно открыть для доступа. Для этого обычно используется функция

```c
FILE* fopen(char* ID_файла, char* режим);
```

она берет внешнее представление - физическое имя файла на носителе и ставит ему в соответствие логическое имя.

Физическое имя, т.е. имя файла и путь к нему задается первым параметром

- строкой, например, `"a:Mas_dat.dat"` - файл с именем `Mas_dat.dat`, находящийся на дискете, `"d:\\\\work\\\\Sved.txt"` - файл с именем `Sved.txt`, находящийся на винчестере, в каталоге `work`.

**Внимание**, обратный слеш (`\\`), как специальный символ в строке записывается дважды!

При успешном открытии функция `fopen()` возвращает указатель на файл (в дальнейшем - указатель файла). При ошибке возвращается `NULL`. Данная ситуация обычно возникает, когда неверно указывается путь к открываемому файлу. Например, если в дисплейном классе нашего университета, указать путь, запрещенный для записи (обычно, разрешенным является `d:\\work\\`).

Второй параметр - строка, в которой задается режим доступа к файлу:

`w` - файл открывается для записи; если файла с заданным именем нет, то он будет создан; если такой файл существует, то перед открытием прежняя информация уничтожается;

`r` - файл открывается только для чтения; если такого файла нет, то возникает ошибка;

`a` - файл открывается для добавления в его конец новой информации;

`r+` - файл открывается для редактирования данных - возможны и запись, и чтение информации;

`w+` - то же, что и для `r+`;

`a+` - то же, что и для a, только запись можно выполнять в любое место файла; доступно и чтение файла;

`t` - файл открывается в текстовом режиме; используются поля `r`, `w`, `a`, `r+`, `w+`, `a+`;

`b` - файл открывается в двоичном режиме.

Текстовый режим отличается от двоичного тем, что при открытии файла как текстового пара символов «перевод строки», «возврат каретки» заменяется на один символ: «перевод строки» для всех функций записи данных в файл, а для всех функций вывода символ «перевод строки» теперь заменяется на два символа: «перевод строки», «возврат каретки».

По умолчанию файл открывается в текстовом режиме.

Пример:

```c
FILE* f; // - объявляется указатель на файл f;

f = fopen ("d:\\\\work\\Dat_sp.cpp", "w"); // - открывается для записи файл с логическим именем f, имеющим физическое имя Dat_sp.cpp, находящийся на диске d, в каталоге work. или более кратко:

FILE* f = fopen ("d:\\\\work\\Dat_sp.cpp", "w");
```

Закрытие файла
--------------

После работы с файлом доступ к нему необходимо закрыть. Это выполняет функция `int fclose(указатель файла)`. Например, из предыдущего примера файл закрывается так:

```c
fclose (f);
```

Для закрытия нескольких файлов введена функция, объявленная следующим образом:

```c
void fcloseall(void);
```

Если требуется изменить режим доступа к файлу, то для этого сначала необходимо закрыть данный файл, а затем вновь его открыть, но с другими правами доступа. Для этого используют стандартную функцию:

```c
FILE* freopen (char* ID_файла, char* режим, FILE* указатель_файла);
```

Эта функция сначала закрывает файл, объявленный `"указателем_файла"` (как это делает функция `fopen`), а затем открывает файл с `"именем_файла"` и правами доступа «режим».

В языке С имеется возможность работы с временными файлами, которые нужны только в процессе работы программы и которые надо удалить после выполнения части вычислений. В этом случае используется функция:

```c
FILE* tmpfile (void);
```

которая создает на диске временный файл с правами доступа "w + b", после завершения работы программы или после закрытия временного файла он автоматически удаляется.

Запись - чтение информации
--------------------------

Все действия по чтению-записи данных в файл можно разделить на три группы:

- операции посимвольного ввода-вывода;

- операции построчного ввода-вывода;

- операции ввода-вывода по блокам.

Рассмотрим основные функции, применяемые в каждой из указанных трех групп операций.

### Посимвольный ввод-вывод

В функциях посимвольного ввода-вывода происходит прием одного символа из
файла или передача одного символа в файл:

```c
int fgetc(FILE* f) // - считывает и возвращает символ из файла f;

int fputc(int ch, FILE* f) // - записывает в файл f код ch символа.
```

### Построчный ввод-вывод

В функциях построчного ввода-вывода происходит перенос из файла, или в
файл строк символов:

```c
int fgets (char \*S, int m, FILE \*f) // - чтение из файла f в строку S m байт;

int fputs (char \*S, FILE \*f) // - запись в файл f строки S до тех пор, пока не встретится `\0`, который в файл не переносится и на символ `\n` не заменяется.
```

### Блоковый ввод-вывод

В функциях блокового ввода-вывода работа происходит с целыми блоками информации:

```c
int fread (void* p, int size, int n, FILE* f) // - считывает n блоков по size байт каждый из файла f в область памяти с указателем p (необходимо заранее отвести память под считываемый блок);

int fwrite (void* p, int size, int n, FILE* f) // - записывает n блоков по size байт каждый из области памяти с указателем p в файл f.
```

Форматированный ввод-вывод производится функциями:

```c
int fscanf (FILE* f, char* формат, список адресов объектов) // - считывает из файла f информацию для объектов в соответствии с указанными форматами;

int fprintf (FILE* f, char* формат, список объектов) // - записывает в файл f объекты, указанные в списке в соответствии с форматами.
```

Данные функции аналогичны функциям `scanf()` и `printf()`, рассмотренным раньше, только добавлен параметр – указатель на файл.

Текстовые файлы
---------------

Для работы с текстовыми файлами удобнее всего пользоваться функциями `fprintf()`, `fscanf()`, `fgets()` и `fputs()`.

Создание текстовых результирующих файлов обычно необходимо для оформления отчетов по лабораторным и курсовым работам.

Рассмотрим пример создания текстового файла:

```c
#include <stdio.h>

void main(void) {
    FILE* f1;
    int a=2, b=3;
    if (!(f1=fopen(“d:\\\\work\\\\f\_rez.txt”,”w+t”)))
    {
        puts("Файл не создан!");
        return;
    }
    fprintf(f1, " Файл результатов \n");
    fprintf(f1, " %d плюс %d = %d\n", a, b, a + b);
    fclose(f1);
}
```

Просмотрев содержимое файла, можно убедиться, что данные в нем располагаются точно как на экране при использовании функции `printf()`.

Бинарные файлы
--------------

Бинарные (двоичные) файлы обычно используются для организации баз данных, состоящих, как правило, из объектов структурного типа. При чтениизаписи бинарных файлов удобнее всего пользоваться функциями, выполняемыми блоковый ввод-вывод `fread()` и `fwrite()`.

Рассмотрим наиболее распространенные функции с помощью которых можно организовать работу с файлами:

```c
int fileno(FILE \*f) // – возвращает значение дескриптора файла f - fd (число, определяющее номер файла);

long filelength(int fd) // – возвращает длину файла, имеющего номер (дескриптор) fd в байтах;

int chsize(int fd, long pos) // – выполняет изменение размера файла, имеющего номер fd, признак конца файла устанавливается после байта с номером pos;

int fseek(FILE \*f, long size, int kod) // – выполняет смещение указателя файла f на size байт в направлении признака kod:
```

> 0 - от начала файла;
> 
> 1 - от текущей позиции указателя;
> 
> 2 - от конца файла;

```c
long ftell(FILE \*f) // – возвращает значение указателя на текущую позицию
файла (-1 – ошибка);

int feof(FILE \*f) // – возвращает ненулевое значение при правильной записи
признака конца файла;

int fgetpos(FILE \*f, long \*pos) // – определяет значение текущей позиции
pos файла f, возвращает 0 при успешном завершении.
```

Пример программы работы с файлом структур:

```c++
    ...

    struct Sved {
        char Fam(30);
        float S_Ball;
    } zapt;

    char Spis[] = "c:\\bc31\\work\\Sp.dat";
    FILE* F_zap;
    FILE* Open_file(char*, char*);
    int i, j, kodR, size = sizeof(Sved);
    while(1) {
        puts("Создание - 1\nПросмотр - 2\nДобавление - 0");
        switch(kodR = gatch())
        {
            case '1': case '3':
                if(kodR == 1)
                {
                    F_zap = Open_file (Spis, "w+");
                }
                else
                {
                    F_zap = Open_file(Spis, "a+");
                }

                while(2)
                {
                    cout << "\n Fam ";
                    cin >> zap.Fam;

                    if( (zap.Fam[0]) == '0' )
                    {
                        break;
                    }

                    cout << "\n Средний балл:";
                    cin >> zap.S_Bal;
                    
                    fwrite(&zap, 1, size, F_zap);
                }

                fclose(F_zap);
                
                break;

            case '2':
                F_zap = Open_file (Spis, "r+");
                int num = 1;
                while(2)
                {
                    if ( fread(&zap, size, 1, F zap) )
                    {
                        break;
                    }
                    printf(" %2d: %20s %5.2f\n", nom++, zap.Fam, zap.Bal);
                }
                    fclose(F_zap):
                    break;

            case 0:
                return; // exit(0);
        } // конец swith
    } // конец while(1)
} // конец программы

FILE* Open_file(char* file, char* kod)
{
    FILE* f;
    if ( !(f = fopen(file, kod)) )
    {
        puts("Файл не создан!");
        getch();
        exit(1);
    }
    else
    {
        return f;
    }
}
```
