<!--
# 2019-12-21_lecture.marktext
-->

## Обмен информации между функциями

При работе программы функции должны обмениваться информацией. Это можно осуществить с помощью:

1) глобальных переменных;

2) параметра;

3) возвращаемое функцией значение.

#Использование глобальных переменных

Глобальные переменные видны во всех функциях, где не описаны локальные переменные с теми же именами. Поэтому использовать их для передачи данных между функциями очень легко, но это не рекомендуется поскольку затрудняет откладку, и припятствует помещении функции в библиотеки общего пользования. Нужно стремится к тому, чтобы функция была максимально независима и интерфейс полностью объявлялся прототипом функции.

Если в теле функции имя глобальной переменной совпадает с локальной, то все операции выполняются с локальной. В этом случае для доступа глобальной переменной необходимо применить операцию оазрешения области видимости (``::``).

Пример:

```c
#include <iostream.h>

int Turn = 5;               //объявление глобальной переменной

int main() {
    int Turn = 70;          //объявление локальной переменной
    cout << Turn << "\n";   //вывод локального значения
    cout << ::Turn << "\n"; //вывод глобального значения
    return 0;
}
```

В результате будет выведено:

```bash
5
70
```

## Использование возвращаемого значения

Механизм возврата из функции вызывающую его функции реализуется оператором

```c
return [выражение];
```

Функция может содержать несколько операций return. Это определяется потребностями алгоритма. После любого из  этих операторов прекращается выполнение функции. Если функция описана как void выражение не указывается оператор return можно отпустить. Выражение указанное после return не явно преобразуется к типу возвращаемого к функции значения и передается в точку вызова функции. Вместо выражения можно записать переменную или константу.

Примеры:

```c
int sum(int a, int b) { return (a + b); }
int f1() { return 1; } //правильно
void f2() { return 1; } //не правильно, f2 не должно возвращать значение
double f3() { return 1; } //правильно, 1 преобразуется к типу double
```

Нельзя возвращать из функции указатель на локальную переменную, потому что память, выделеная локальным переменым освобождается после возврата функции.

Пример, как нельзя делать:

```c
int *f() { int a = 5; return &a; } //нельзя!
```

Если тип возвращаемого функцией не void, она может входить в состав выражений или, в частном случае, распологаться в правой части оператора присваивания.

Пример:

```c
c = sum(a, b);
```

## Использование параметров функции

Механизм парамтров является основным способом обмена информации между вызываемой и вызывающей функцией.

Параметры перечисленные в загаловке описания функции называются <u>формальные</u>, а записанные в операторе вызова функции <u>фактическими</u>.

При вызове функции первую очередь вычисляются выражения стоящие на месте фактических параметров, затем в теке выделяется память под формальный параметр функции. В соответствии с их типом и каждому из них присваивается значение соответствующего фактического параметра. ПРи этом проверяется соотвествии типа. ПРи необходимости выполняется приобразования типа, либо выдаётся сообщение об ошибке.

Существует 2-ва способа передачи параметров функции:

1) По значению

2) По адресу

При передачи по значению на месте формальном параметров записываются значения фактичеких параметров. Вычисление функции в стек записывают копии и оператор функции работает с этим копиями. Доступа к исходным параметрам функции нет, и нет возможности их поменять.

При передаче по адресу в стек заносятся копии адресов параметров через указатель, ссылку и операцию взятия адреса. Следовательно функция осуществляет доступ память по адрусу, а значит может подменять эти параметры.

Пример:

```c
void f(int i, int *j, int &k);

int main() {
    ...
    int i = 1, j = 2, k = 3;
    cout << "i j k/n";
    cout << i << " " << j << " " << k << "/n";
    f(i, &j, k);
    cout << i << " " << j << " " << k << "/n";
    ...
}

void f(int i, int *j, int &k) {
    i++;
    (*j)++;
    k++;
}
```

Результат работы программы:

```bash
i j k
1 2 3
1 3 4
```

i - передаётся по значению. Его приминение функции не влияет на исходное значение, т. к. функция его применить не может.

j - передаётся по адресу с помощью указателя, при этом для передачи фактического параметра используется операция взятия адреса, а для получения его значения функции требуется операция разименования

k -передается по адресу с помощью ссылки

При передачи ссылки передаётся адрес указаного при вызове параметра, а внутри функции все обращения не явно разименовываются. Поэтому использование ссылок вместо указателей улутшает читаемость программы, избавляя от необходимости использовать операци. получения адреса и разименования. Использование ссылкок вместо передачи по значению более эффективно, потому что имеет... что структур... большого объема.

## Модификатор функции

Если требуется запретить изменение параметра внутри функции, используется модификатор const:

```c
int f(const char*);
char *t(char *a, const int *b);
```

Рекомендуется указывать const перед всеми параметрами, изменение которых не предусмотрено. Это облегчает откладку больших программ.

## Передача массивов в качестве паметров

При передаче массивов функции передается указатель на его первый элемент. Иным слова массив всегда передаётся по адресу, при этом информация о количестве элементов массиватеряется, и следует передавать размерность через отдельный параметр. В случае строки его длину можно определить через функцию `sizeof()`.

Пример передачи массивов:

```c
int sum(const int *mas, const int n);

int main() {
    ...
    int const n = 10;
    int marks[n] = {3, 4, 5, 4, 4};
    cout << Rus("Сумма элементов массива: ") << sum(marks, n);
    ...
}

int sum(const int *mas, const int n){
    //Варианты:
    //int sum(int mas[], int n)
    //int sum(int mas[n], int n)
    //(величина n быть константой)
    int s = 0;
    for (int i = 0; i < n; i++)
        s += mas[i];
    return s;
}
```
